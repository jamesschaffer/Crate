# Project Context -- AlbumCrate

## Overview

AlbumCrate (display name; codebase still uses "Crate" internally) is a single-purpose native app built on Apple Music that strips away playlists, podcasts, algorithmic feeds, and social features to deliver a focused album listening experience. Users browse a two-tier genre taxonomy (inspired by musicmap.info), see a grid of album cover art, pick an album, and listen to it start to finish. The interface is designed to feel like thumbing through records in a store, not using a software application.

AlbumCrate is a SwiftUI multiplatform app targeting iOS and macOS, powered by MusicKit for Apple Music integration. There is no server or backend -- the app is fully client-side.

## Current Status

**Active development.** Core features, Crate Wall, personalized genre feeds, grid transition animations, now-playing progress bar, playback scrubber, launch animation, brand identity, artist catalog browsing, and auto-advance album playback are implemented. The macOS target is now buildable and testable (keyboard shortcuts, Settings scene, platform-specific UI fixes). Visual design polish is in progress.

- PRD: Complete (Draft -- Architecture Complete, MusicKit Pivot)
- Architecture decisions: 31 ADRs documented (ADR-100 through ADR-130)
- Core app: Implemented (Browse, Album Detail, Playback, Auth, Favorites, Dislikes)
- Crate Wall: Complete -- algorithm-driven landing experience with 5 blended signals, Crate Dial settings, enriched genre extraction (heavy rotation + library albums), dislike filtering, infinite scroll, graceful degradation
- Genre feeds: Complete -- multi-signal blended genre feeds (6 signals: Personal History, Recommendations, Trending, New Releases, Subcategory Rotation, Seed Expansion), CrateDial-weighted, replaces single-source chart pagination
- Grid transitions: Complete -- coordinated scatter/fade animation when switching between wall and genre or between genres. GridTransitionCoordinator state machine orchestrates exit, scroll-reset, fetch, and enter phases. Genre bar disabled during transitions. Zero overhead during idle.
- Feedback loop: Complete -- like write-back fires 3 concurrent Apple Music calls (addToLibrary + rateAlbum(.love) + favoriteAlbum via POST /v1/me/favorites), dislike writes rateAlbum(.dislike), disliked albums filtered from all feeds, mutual exclusion between like and dislike, error logging on all write-back calls. `addToLibrary` uses `MusicLibrary.shared.add()` on iOS and REST API `POST /v1/me/library` on macOS (the MusicKit-native API is iOS-only)
- Genre taxonomy: Complete -- 9 super-genres with ~50 subcategories, mapped to real Apple Music genre IDs
- Genre bar: Complete -- single-row transforming filter bar (genres view OR selected-genre + subcategory pills view), search-based subcategory browsing, staggered slide animation synchronized with grid transitions for genre-level switches (pills slide down on exit, up on enter), disabled during transitions. Uses vertical offset workaround for Liquid Glass compositing limitations (animated opacity and scaleEffect do not work correctly with .glassEffect())
- Settings: Complete -- Crate Algorithm radio selector with 5 tappable positions (full-sheet on iOS, Settings scene on macOS). On macOS, the Settings scene requires explicit environment injection (playbackViewModel, modelContainer) because macOS window scenes do not inherit @Environment from the main WindowGroup. Dial changes regenerate the Crate Wall live (no app restart required), "My Personal Taste" to "Mystery Selections" spectrum labels, Algorithm Diagnostics debug panel (validates favorites/dislikes persistence, mutual exclusion, weight correctness), Queue Diagnostics debug panel (queue state, batch albums, track-to-album mapping, pre-fetch status)
- Album Detail: Redesigned with blurred artwork ambient background, now-playing track indicator, like/dislike buttons in side gutters flanking artwork, play button and track list tinted with artwork-derived colors, dedicated playback scrubber between transport controls and track list (visible only for the now-playing album), tappable artist name navigates to artist catalog, streamlined layout. On macOS, `.buttonStyle(.plain)` is applied to like/dislike buttons, play/pause button, and artist NavigationLink to suppress default macOS button chrome. Navigation title is hidden on macOS (redundant with content area title, matches Apple Music pattern)
- Artist catalog: Complete -- tapping the artist name on AlbumDetailView navigates to a full-bleed grid of all albums by that artist, sorted oldest-first (chronological discography). Uses ArtistCatalogViewModel with two-step fetch (album -> artist ID -> artist albums via MusicDataRequest). Reuses AlbumGridView for consistent grid layout. Navigation powered by CrateDestination enum
- Auto-advance playback: Complete -- playing an album from any grid (Crate Wall, genre feed, artist catalog) automatically continues through the grid. Grid context (album list + tapped index) is passed through the navigation system via a `GridContext` struct embedded in `CrateDestination.album`, rather than through gestures (SwiftUI swallows `simultaneousGesture` on `NavigationLink`). `AlbumDetailView` receives grid context from its destination and sets it in `.task` -- deterministic, no race condition. AlbumQueueManager (pure logic, no MusicKit dependency) manages batch composition (5 albums) and track-to-album mapping. When the user taps play, all batch albums' tracks are fetched upfront (anchor tracks already loaded; remaining albums fetched with 500ms throttle) and a single complete MusicKit queue is built before playback starts -- a spinner shows during loading. This avoids mid-playback queue rebuilds that caused audible restarts and UI flickering. `play(tracks:startingAt:from:)` has three paths: within-batch (reuses existing queue, preserves auto-advance), preloader (first play from grid, fetches all batch tracks), and normal (single-album, no grid context). Track list taps on an already-playing batch album use the within-batch path and `seekToTrack(at:)` to avoid resetting auto-advance state. `nowPlayingAlbum` is set after `player.play()` returns in all paths to prevent premature footer/scrubber appearance. `trackDidChange(to:checkBackward:)` supports skip-backward by checking one position back (not a full backward scan, so queue-wrap detection still works). Pre-fetches next batch when reaching the last album. 28 unit tests. QueueDiagnosticsView in Settings for debugging
- Now-playing progress bar: Complete -- visual-only progress bar with artwork-derived gradient in the playback footer and BrowseView control bar (no drag gesture; scrubbing relocated to AlbumDetailView). ArtworkColorExtractor uses pure CoreGraphics (cross-platform, no UIKit/AppKit).
- Playback scrubber: Complete -- dedicated `PlaybackScrubber` component in AlbumDetailView between transport controls and track list. 54pt touch target, 6-to-14px height expansion on touch for feedback, thumb knob appears on touch, artwork-derived gradient with rounded corners. On iOS, uses a UIKit `UILongPressGestureRecognizer(minimumPressDuration: 0)` via `UIViewRepresentable` to bypass UIScrollView's ~150ms touch delay (SwiftUI DragGesture inherits the delay). An `@Observable ScrubState` class bridges UIKit gesture state to SwiftUI (closures capturing @State do not trigger re-renders when called from UIKit). 1s post-seek cooldown prevents the timer from snapping the bar back. Only appears when viewing the currently-playing album, animated with 0.35s ease-in-out fade. Footer progress bar hidden on now-playing album page to avoid duplication.
- Control bar launch animation: Complete -- control bar hidden during initial wall load, slides up with spring animation (.spring(duration: 0.5, bounce: 0.15)) after albums appear + 400ms delay. The control bar is rendered inside `.safeAreaInset(edge: .bottom)`, which automatically extends into the home indicator safe area -- no explicit GeometryReader padding is needed.
- Display name: Set to "AlbumCrate" (codebase still uses "Crate" internally for project, targets, and module names)
- Brand identity: Complete -- app icon (magenta wireframe cube), branded welcome screen (AlbumCrateLogo + AlbumCrateWordmark on black background, "Link to Apple Music" button), brand color `brandPink` (#df00b6) applied app-wide via root `.tint()` modifier, AccentColor.colorset set as fallback, all ProgressView spinners standardized to `.tint(.brandPink)` at default size
- Design: Visual design in progress (album detail, playback UI, and welcome screen polished; other views pending)

**Note on history:** Crate was originally designed as a Spotify web app (Next.js + React). On 2026-02-09, the project pivoted to Apple Music + native SwiftUI. The original Spotify-era ADRs (001-014) are archived in git history. All current documentation reflects the Apple Music / MusicKit direction.

## Tech Stack

| Layer | Choice |
|-------|--------|
| Platform | SwiftUI Multiplatform (iOS 17+ / macOS 14+) |
| Architecture Pattern | MVVM with `@Observable` |
| Music Integration | MusicKit (Apple Music) |
| Playback | `ApplicationMusicPlayer` |
| API Access | MusicKit Swift types + `MusicDataRequest` |
| Local Persistence | SwiftData |
| Image Caching | `AsyncImage` + system URL cache |
| Validation | Swift type system (compile-time) |
| Testing | XCTest (UI tests) + Swift Testing (unit tests) |
| Deployment | App Store (iOS + macOS), TestFlight for beta |
| CI/CD | Xcode Cloud |
| Server / Backend | None |
| Database | None (SwiftData is on-device only) |

## Key Constraints

- **No Simulator support for MusicKit.** MusicKit playback and subscription checks do not work in the iOS Simulator. Integration testing and UI testing require a physical device with an active Apple Music subscription. Unit tests with mocked MusicKit can run in the Simulator.
- **MARKETING_VERSION and CURRENT_PROJECT_VERSION are required for MusicKit personalized endpoints.** If these build settings are missing from the Xcode project, MusicKit silently fails every `/v1/me/*` API call (heavy rotation, recently played, recommendations, library albums, ratings, favorites) with "Missing requesting bundle version." Both settings must be present in all build configurations (Debug + Release) for both iOS and macOS targets. All API calls, SwiftData saves, and URL construction steps use `do/catch` with `[Crate]`-prefixed `print` logging -- there are no silent `try?` patterns anywhere in the codebase. Failures are always visible in the Xcode console.
- **Charts endpoint popularity bias.** The Apple Music Charts API returns albums ranked by current streaming popularity, not all-time catalog depth. Deep catalog albums from older decades may not appear unless they are currently popular. This is acceptable for MVP. Subcategory browsing now uses the Apple Music Search endpoint (not charts), which provides broader catalog coverage for sub-genre exploration.
- **Apple Music genre granularity.** Apple Music has roughly 20-30 top-level genres, which is more conservative than some platforms with hundreds of micro-genres. Some sub-categories in the taxonomy may map to the same genre ID. This needs validation during taxonomy mapping.
- **Rate limits.** Apple Music API allows approximately 20 requests per second per user token. With 1 API call per page of album results, this is nearly a non-issue. Defensive debounce and 429 retry are implemented as safety measures.
- **Token management is automatic.** MusicKit handles developer tokens and user tokens at the system level. There are no tokens to store, refresh, or rotate. The ~6-month token expiry concern applies only to the REST API used from servers, not to native MusicKit apps.
- **Apple ecosystem only.** No Android, no web, no Windows. The app requires an Apple device with iOS 17+ or macOS 14+. Cross-platform would require a separate effort (MusicKit.js for web, or a full rebuild for Android).
- **No server needed.** MusicKit handles auth, API access, and playback on-device. No client secret, no OAuth flow, no API proxy. The entire app is client-side.
- **`MusicLibrary.shared.add()` is iOS-only.** This MusicKit API for adding items to the user's library does not exist on macOS. The REST API `POST /v1/me/library?ids[albums]={id}` is the cross-platform alternative. The codebase uses the MusicKit-native call on iOS and the REST fallback on macOS.
- **macOS `Settings` scene does not inherit `@Environment`.** The `Settings` window scene is independent from the main `WindowGroup`. Any environment values (view models, model containers) needed by Settings must be explicitly injected in `CrateApp.swift`. Forgetting this causes a crash on macOS.
- **macOS renders button chrome by default.** `Button` and `NavigationLink` show background rectangles and hover highlights on macOS unless `.buttonStyle(.plain)` is set. New interactive elements in custom layouts need this modifier on macOS.
- **Never hand-edit pbxproj for build settings.** Build setting changes (display name, version numbers, signing, etc.) must go through Xcode's UI. External edits to `project.pbxproj` can cause Xcode to get stuck showing raw XML source instead of the project editor.
- **`safeAreaInset` safe area behavior.** `.safeAreaInset(edge: .bottom)` automatically extends its content into the safe area (e.g., the home indicator region) -- explicit GeometryReader padding is NOT needed and will double the offset. However, `.ignoresSafeArea()` on backgrounds within safeAreaInset content has no effect because safe area information is not propagated to children. If you need a background to extend beyond the inset content itself, use `.background()` on the safeAreaInset content rather than `.ignoresSafeArea()` on a child.

## Key Documents

| Document | Path | Description |
|----------|------|-------------|
| PRD | [PRD.md](./PRD.md) | Full product requirements, UX specification, and architecture |
| Decision Log | [DECISIONS.md](./DECISIONS.md) | 31 architectural decision records (ADR-100 through ADR-130) |
| README | [README.md](./README.md) | Project overview and getting started |

## Architecture Summary

The application has six view areas (Auth/Welcome, Browse with Crate Wall, Album Detail, Artist Catalog, Playback Footer, Settings) and no backend. A brand color (`brandPink`, #df00b6) is defined in `AppColors.swift` and applied app-wide via `.tint(.brandPink)` on the root view in `CrateApp.swift`, replacing the default iOS blue accent on all interactive controls. The `AccentColor.colorset` is set to the same value as a fallback. The Auth/Welcome screen displays the AlbumCrate logo and wordmark on a black background with a magenta "Link to Apple Music" button. The Album Detail view uses a ZStack with blurred, scaled album artwork as an ambient background layer, a dimming overlay at 50% opacity for readability (reduced from 75% to let more artwork color bleed through), and the scrollable content on top. All Apple Music API calls are made directly from the app via MusicKit. Auth is handled by the system via a single MusicKit authorization dialog. ContentView isolates playback state observation into a child `PlaybackFooterOverlay` view so that `stateChangeCounter` updates only re-render the footer, not the entire NavigationStack. The same isolation pattern is used in AlbumDetailView: transport controls are extracted into a private `AlbumTransportControls` child view that owns the `stateChangeCounter` read, preventing playback state changes from re-rendering the expensive blur background. A hidden `ShaderWarmUpView` (invisible 1x1 Color.gray with scaleEffect + blur) in ContentView's background forces Metal to pre-compile the blur/scale shaders at launch, preventing a visible stutter on the first AlbumDetailView push.

On launch, the control bar (genre filter pills + playback row) is hidden while the Crate Wall loads. After albums appear, the bar slides up from the bottom with a spring animation (0.5s, 0.15 bounce) after a 400ms polish delay. The bar is rendered inside `.safeAreaInset(edge: .bottom)`, which automatically extends the content and its material background into the home indicator safe area.

The default landing experience is the Crate Wall -- an algorithm-driven grid of album art blending five signals (Listening History, Recommendations, Popular Charts, New Releases, Wild Card), weighted by a user-controllable "Crate Dial" radio selector persisted to UserDefaults. Genre extraction uses heavy rotation, library albums, and recently played for richer personalization. The wall persists within a session and regenerates on cold launch or when the user selects a new Crate Dial position.

Users can switch to genre-based browsing via the genre bar. Genre feeds use a multi-signal blending system (GenreFeedService) with 6 signals: Personal History (heavy rotation + library filtered to genre), Recommendations (filtered to genre), Trending (charts with random offset), New Releases, Subcategory Rotation (random subcategories for variety), and Seed Expansion (related albums + artist albums from user's favorited seeds). Weights follow the CrateDial system via GenreFeedWeights. Subcategory selection uses the Apple Music Search endpoint for targeted browsing. Both CrateWallService and GenreFeedService share generic utilities from `WeightedInterleave.swift`: `weightedInterleave()` for the interleave algorithm and `distributeByWeight()` for converting fractional weight tables to integer album counts using the largest-remainder method (replacing duplicated implementations in CrateDialWeights and GenreFeedWeights).

Switching between the wall and a genre (or between genres) is animated via a `GridTransitionCoordinator` -- an `@Observable` state machine with four phases: `idle` (passthrough, no overhead), `exiting` (old albums scatter out with staggered scale+fade), `waiting` (scroll resets to top, API fetch runs concurrently, spinner shown if needed), and `entering` (new albums scatter in). `BrowseView` uses a single always-mounted `AlbumGridView` inside a `ZStack` with overlay states (loading, error, empty). During idle, the grid reads albums directly from the wall or genre view model. During transitions, it reads from the coordinator's `displayAlbums`. Each grid item is wrapped in `AnimatedGridItemView`, which reads per-item scale/opacity from the coordinator via `@Environment`. The first 16 items get a staggered scatter effect with interleaved groups and random jitter; items beyond 16 get a bulk fade. All genre selection callbacks route through `coordinator.transition(from:fetch:)`. The genre bar is disabled during transitions to prevent double-tap race conditions. Rapid taps cancel the in-progress transition and start a new one. Animation tuning constants are centralized in `GridTransitionConstants.swift` (`GridTransition` enum). The genre bar pills also participate in the transition animation for genre-level switches (not subcategory toggles): pills stagger-slide downward on exit and upward on enter, synchronized with the grid scatter timing. The `animateGenreBar` flag on the coordinator distinguishes genre-level transitions (animated pills) from subcategory toggles (pills not animated). The slide animation uses vertical `offset` instead of opacity or scaleEffect because Liquid Glass compositing layers (`.glassEffect()`) do not support animated opacity and render text/capsule as separate layers that break scaleEffect. Offset is applied in dual locations -- on the label content and post-glassEffect -- to handle the layer bifurcation. `.clipped()` on the ScrollView ensures pills are hidden when offset below the bar.

A feedback loop connects Crate interactions to Apple Music: favoriting an album fires three concurrent API calls -- `addToLibrary` (adds to library), `rateAlbum(.love)` (marks as loved), and `favoriteAlbum` (POST `/v1/me/favorites`, marks with the star icon in Apple Music's Favorites system, iOS 17.1+). Disliking fires `rateAlbum(.dislike)`. All write-back calls use explicit error logging (`do/catch` with print) instead of silent `try?`, so failures are visible in the console. Disliked albums (stored via SwiftData's `DislikedAlbum` model) are filtered from all feeds. Like and dislike are mutually exclusive. This trains Apple Music's recommendation algorithm over time, creating a virtuous cycle where Crate interactions improve the recommendations that feed back into Crate.

**Important: SwiftData modelContext injection.** ViewModels that use FavoritesService or DislikeService (`AlbumDetailViewModel`, `BrowseViewModel`) are created with `@State` (no modelContext at init time). Views must call `viewModel.configure(modelContext:)` in their `.task` modifier before any CRUD operations. The `modelContext` comes from `@Environment(\.modelContext)` in the view. Without this step, all SwiftData operations silently no-op in production. In DEBUG builds, every `guard let ctx = modelContext` block fires `assertionFailure("[Crate] modelContext is nil â€” did you forget to call configure()?")`, crashing immediately so the misconfiguration is caught during development.

Playback uses `ApplicationMusicPlayer` with an independent queue, providing native background audio, lock screen controls, and Now Playing integration automatically. The track list shows a now-playing indicator (play icon replaces track number) for the currently playing track, tinted with a color extracted from the album artwork. A shared `PlaybackRowContent` view (in PlaybackFooterView.swift) provides the artwork + track info + play/pause row used by both the `PlaybackFooterView` mini-player and BrowseView's inline control bar, eliminating duplicated playback UI code. `PlaybackRowContent` reads `stateChangeCounter` directly in its body for self-sufficient state observation. A `PlaybackProgressBar` sits above the playback row (as a layout sibling, not an overlay) in both the footer and the BrowseView control bar. The bar is visual-only (no drag gesture) and shows track progress with a gradient fill derived from the album artwork's two most prominent colors, extracted by `ArtworkColorExtractor`. Progress updates every 0.5s via `Timer.publish`. `PlaybackFooterView` accepts a `showProgressBar` parameter (defaults `true`) to conditionally hide the progress bar -- used when AlbumDetailView is showing the now-playing album, to avoid duplicate bars. A dedicated `PlaybackScrubber` component (`Crate/Views/Playback/PlaybackScrubber.swift`) is placed in `AlbumDetailView` between the transport controls and the track list. It provides a full-width scrub-capable bar with a 54pt touch target, 6-to-14px height expansion on touch for feedback, a thumb knob on touch, and the same artwork-derived gradient with rounded corners. The scrubber only appears when viewing the currently-playing album (`isPlayingThisAlbum`), animated with `.transition(.opacity)` and `.animation(.easeInOut(duration: 0.35))`. On iOS, the scrubber uses a `UILongPressGestureRecognizer(minimumPressDuration: 0)` via `UIViewRepresentable` (`ScrubGestureOverlay`) instead of SwiftUI's `DragGesture` -- UIScrollView delays content touches by ~150ms to disambiguate scrolling, and SwiftUI gestures inherit this delay. UIKit gesture recognizers bypass it because they receive touches directly from the hit-testing pipeline. An `@Observable ScrubState` class bridges gesture state from UIKit to SwiftUI (closures capturing `@State` fail to trigger re-renders when called from UIKit). On macOS, the standard `DragGesture` is used (no scroll view delay issue). The parent scroll view's pan gesture is temporarily disabled during scrubbing to prevent simultaneous scrolling. A 1-second cooldown after seeking prevents the 0.5s timer from snapping the progress bar back to the pre-seek position before the player catches up. Both `PlaybackScrubber` and `PlaybackProgressBar` use `.onChange(of: viewModel.trackDuration)` to immediately sync `currentTime` on track changes, eliminating the stale-position display between tracks that the 0.5s timer would otherwise cause. `PlaybackViewModel` tracks `trackDuration` and `currentTracks` to support the progress calculation, with `syncTrackDuration()` updating duration when the player advances tracks. `ArtworkColorExtractor` uses pure CoreGraphics/ImageIO (no UIKit/AppKit) for cross-platform compatibility -- it downloads a 40x40 thumbnail, downsamples to 10x10, quantizes pixels into RGB buckets, scores them with saturation-cubed weighting (biasing toward vivid saturated colors over whites/grays/pastels), filters out near-blacks and desaturated colors, and selects two colors with sufficient contrast. Results are cached by URL. The same extractor is used in `AlbumDetailView` to tint the play button, the scrubber gradient, and pass a `tintColor` to `TrackListView`.

When an album is played from a grid context (Crate Wall, genre feed, or artist catalog), playback auto-advances through the grid instead of stopping at the end of the album. Grid context flows through the navigation system: a `GridContext` struct (containing the album list and tapped index) is embedded directly in `CrateDestination.album` as an optional parameter. When `AlbumDetailView` loads, it reads the grid context from its destination in `.task` and calls `setGridContext` on `PlaybackViewModel` -- this is deterministic and avoids the race condition that existed with the previous gesture-based approach (SwiftUI swallows `simultaneousGesture(TapGesture())` on `NavigationLink`, so gesture-based side effects never fire). `AlbumQueueManager` (`Crate/Services/AlbumQueueManager.swift`) is a pure logic class (no MusicKit dependency) that manages the grid context (ordered album list + current index), composes batches of 5 albums, maps tracks back to source albums using forward search (handles duplicate titles like "Intro"), and determines when the next batch should be pre-fetched. When the user taps play, `PlaybackViewModel` shows a loading spinner (`isPreparingQueue`) and fetches tracks for ALL batch albums upfront (anchor tracks are already loaded from `AlbumDetailViewModel`; remaining albums are fetched sequentially with a 500ms throttle). Only after all tracks are ready does it build a single complete MusicKit queue and call `player.play()`. This "load everything, then play once" approach avoids mid-playback queue rebuilds that caused audible restarts, UI flickering, and broken auto-advance. `nowPlayingAlbum` is set after playback starts (not before) so the footer and scrubber do not appear prematurely during loading. `PlaybackViewModel` maintains a `prefetchTask` reference for pre-fetching the next batch when nearing the end of the current one. `AlbumDetailViewModel` includes retry logic for transient track fetch failures. A `QueueDiagnosticsView` in Settings shows queue state, batch albums, track-to-album mapping, and pre-fetch status for debugging. Navigation uses a typed `[CrateDestination]` array (not type-erased `NavigationPath`) so the path is inspectable. `CrateDestination` is an enum with cases `.album(CrateAlbum, gridContext: GridContext?)` and `.artist(name: String, albumID: MusicItemID)`, supporting multiple destination types in a single NavigationStack. `PlaybackFooterOverlay.navigateToNowPlaying()` guards against duplicate pushes by pattern-matching `navigationPath.last` against `.album`. `BrowseView` accepts the typed `navigationPath` binding from `ContentView` so the playback row can navigate to the now-playing album's detail view. `BrowseView`'s `.navigationDestination(for: CrateDestination.self)` switches on the enum to route `.album` to `AlbumDetailView` and `.artist` to `ArtistCatalogView`. Favorites are stored locally via SwiftData and also synced to Apple Music library. The UI is built with SwiftUI using MVVM with six `@Observable` view models (`AuthViewModel`, `BrowseViewModel`, `AlbumDetailViewModel`, `ArtistCatalogViewModel`, `PlaybackViewModel`, `CrateWallViewModel`), all annotated with `@MainActor` at the class level for thread-safe property mutations. A single multiplatform codebase targets both iOS and macOS with 95%+ shared code, using `#if os(iOS)` / `#if os(macOS)` conditionals for the small number of platform-specific APIs (e.g., `UIColor.systemBackground` vs `NSColor.windowBackgroundColor`, `MusicLibrary.shared.add()` vs REST API `POST /v1/me/library`, `.toolbar(.hidden, for: .navigationBar)`, `.navigationTitle("")` on macOS for hidden nav titles). On macOS, `CrateApp.swift` wires up `PlaybackCommands` for standard keyboard shortcuts (Space, Cmd+Arrows, Cmd+.) and explicitly injects `playbackViewModel` and `modelContainer` into the `Settings` scene (macOS window scenes do not inherit environment from the main `WindowGroup`). The macOS window defaults to 800x800. macOS button chrome is suppressed with `.buttonStyle(.plain)` on interactive elements in custom layouts.

## Open Items

- **Visual design.** The PRD defines the UX and layout but not the visual design system (colors, typography, spacing). Brand color (`brandPink` #df00b6) is established and applied app-wide. Album Detail, playback UI, and welcome screen have been polished. Other views (Browse grid) still need visual polish. Settings and Feed Diagnostics have been polished (radio selector, bumped font sizes, standardized spinners).
- **Charts depth testing.** Apple does not document a maximum offset for the charts endpoint. Empirical testing is needed to determine how many albums per genre we can paginate through.
- **Testing coverage.** Unit tests exist for MusicServiceTests, BrowseViewModelTests (4 tests using MockMusicService), CrateWallServiceTests (3 tests: wall generation, empty signals, dislike filtering), GenreTaxonomyTests, FavoritesServiceTests, DislikeServiceTests (CRUD, dedup, fetchAllDislikedIDs), FeedbackLoopTests (mutual exclusion, GenreFeedWeights correctness, weighted interleave), and AlbumQueueManagerTests (28 tests: batch composition, track-to-album mapping, batch boundary detection, backward search, seekToTrack, edge cases). A configurable `MockMusicService` (implementing `MusicServiceProtocol`) supports preset albums, tracks, chart results, search results, and error injection. UI test stubs exist (BrowseFlowTests, PlaybackFlowTests). Tests use `@testable import Crate_iOS` (the iOS target's module name) and in-memory SwiftData containers. Tests need to be run on physical devices for MusicKit-dependent paths.
- **CloudKit sync for favorites/dislikes.** Favorites and dislikes are currently device-local. Cross-device sync via CloudKit is a future consideration.

## Resolved Items

- **MusicKit "Missing requesting bundle version" error.** Resolved. All personalized `/v1/me/*` endpoints were silently failing because `MARKETING_VERSION` and `CURRENT_PROJECT_VERSION` were missing from the Xcode build settings. Added to all four build configurations (iOS Debug, iOS Release, macOS Debug, macOS Release). All API calls and SwiftData saves now use `do/catch` with `[Crate]`-prefixed error logging instead of silent `try?` -- applied consistently across CrateWallService, GenreFeedService, FavoritesService, and DislikeService.
- **Genre taxonomy mapping.** Resolved. The taxonomy is implemented in `Genres.swift` with 9 super-genres and ~50 subcategories, mapped to real Apple Music genre IDs. The original PRD proposed 15 super-genres / ~100 sub-categories, but the actual Apple Music genre hierarchy supported 9 well-differentiated super-genres.
- **Super-genre count.** Resolved. Settled on 9: Rock, Pop, Hip-Hop, Electronic, R&B, Jazz, Country, Classical, Latin.
- **macOS build errors.** Resolved (ADR-126). Three iOS-only APIs were breaking the macOS target: `Color(.systemBackground)` in AlbumDetailView (replaced with `#if os(iOS)` / `#else` conditional using `NSColor.windowBackgroundColor`), `MusicLibrary.shared.add()` in MusicService (wrapped in `#if os(iOS)`), and `.toolbar(.hidden, for: .navigationBar)` in BrowseView (wrapped in `#if os(iOS)`). Both targets now compile cleanly.
- **macOS target functional testing.** Resolved (ADR-130). The macOS target compiled after ADR-126 but was not usable as an application. Six fixes brought it to a testable state: PlaybackCommands keyboard shortcuts (Space, Cmd+Arrows, Cmd+.), Settings scene environment injection (playbackViewModel + modelContainer -- macOS window scenes do not inherit @Environment from WindowGroup), REST API fallback for `addToLibrary` (`MusicLibrary.shared.add()` is iOS-only; `POST /v1/me/library` works cross-platform), `.buttonStyle(.plain)` on macOS to suppress button chrome, hidden navigation title on macOS album detail, and updated auth denied text to current System Settings path. Xcode project configured with automatic signing, "AlbumCrate" display name, and Music app category for macOS.
- **Concurrency isolation on view models.** Resolved. All five `@Observable` view model classes now have class-level `@MainActor` annotation, ensuring all property mutations that drive SwiftUI updates happen on the main thread. Twelve redundant per-method `@MainActor` annotations were removed.
- **Silent error patterns.** Resolved. All remaining `try?` patterns in GenreFeedService replaced with `do/catch` logging. All 8 `guard let url` blocks in MusicService now log URL construction failures with `[Crate]` prefix. The entire codebase uses consistent `do/catch` with `[Crate]`-prefixed error logging -- no silent `try?` remains.
- **Subcategory search performance.** Resolved. `BrowseViewModel.fetchSubcategoryAlbums()` was calling the search API sequentially in a for-loop. Replaced with `withThrowingTaskGroup` for concurrent execution, reducing latency proportionally to the number of subcategory terms.
- **Hardware testing plan.** Development is happening on physical devices with an active Apple Music subscription.
